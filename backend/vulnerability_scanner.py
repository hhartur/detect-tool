import re
import os
import sys
import requests
import json
from shutil import which
from datetime import datetime
from urllib.parse import urlparse, urljoin, parse_qs, urlencode
from bs4 import BeautifulSoup

from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeoutError

class VulnerabilityScanner:
    def __init__(self, max_threads=50):
        self.findings = []
        self.max_threads = max_threads
        self.tool_paths = self._find_tools([])
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "\'\"><script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
        ]
        self.sqli_payloads = [
            "' OR 1=1 --",
            "1' UNION SELECT NULL,NULL,NULL--",
            "1' AND SLEEP(5)--",
        ]
        self.lfi_payloads = [
            "../../../../etc/passwd",
            "....//....//....//....//etc/passwd",
        ]
        self.vulnerability_indicators = {
            "XSS": ["<script>alert('XSS')</script>", "'>\"><script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>"],
            "SQLi": ["SQL syntax", "mysql_fetch_array", "Unclosed quotation mark"],
            "LFI": ["root:x:0:0:", "daemon:x:", "bin:x:"]
        }
        self.tested_params = set()
        self.submitted_form_signatures = set()

    def get_missing_tools(self):
        return []

    def _find_tools(self, tools):
        return {}

    def run_full_scan(self, target, log_callback, update_callback, enable_browser_scan=True):
        self.findings = []
        self.log_callback = log_callback
        self.update_callback = update_callback
        self.tested_params.clear()
        self.submitted_form_signatures.clear()
        
        all_discovered_urls = set()
        discovery_report = ""
        browser_discovery_report = ""

        if enable_browser_scan:
            update_callback("Fase 1: Iniciando Descoberta de Superfície de Ataque e Varredura Ativa (Browser)...")
            browser_discovery_report, browser_discovered_urls = self._browser_based_scan(target)
            all_discovered_urls.update(browser_discovered_urls)
            self.log_callback("INFO", f"Análise do navegador concluída. {len(browser_discovered_urls)} URLs únicas descobertas no domínio alvo.")
        else:
            pass
        
        update_callback("Gerando sumário de risco...")
        summary_report = self._generate_summary()

        return {
            "target": target, "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "summary_report": summary_report,
            "discovery_report": browser_discovery_report,
        }

    def _add_finding(self, severity, description):
        self.findings.append({"severity": severity, "description": description})

    def _browser_based_scan(self, start_url):
        discovered_urls = set()
        report_lines = []
        target_netloc = urlparse(start_url).netloc
        
        with sync_playwright() as p:
            browser = p.chromium.launch(headless=True)
            context = browser.new_context()
            page = context.new_page()

            def handle_route(route):
                request = route.request
                request_netloc = urlparse(request.url).netloc
                if request_netloc == target_netloc or request_netloc.endswith('.' + target_netloc):
                    self._perform_active_scan_on_request(request)
                route.continue_()

            page.route("**/*", handle_route)

            urls_to_visit = {start_url}
            visited_urls = set()
            
            while urls_to_visit and len(visited_urls) < 100:
                current_url = urls_to_visit.pop()
                
                if '?' in current_url:
                    current_url = current_url.split('?')[0]
                
                current_url = current_url.rstrip('/')
                parsed_current_url = urlparse(current_url)

                if current_url in visited_urls or not (parsed_current_url.netloc == target_netloc or parsed_current_url.netloc.endswith('.' + target_netloc)):
                    continue
                
                visited_urls.add(current_url)
                discovered_urls.add(current_url)
                self.log_callback("INFO", f"Navegando para: {current_url}")
                report_lines.append(f"Visitando: {current_url}")

                try:
                    page.goto(current_url, wait_until="domcontentloaded", timeout=20000)
                    
                    raw_hrefs = page.eval_on_selector_all("a", "elements => elements.map(el => el.getAttribute('href'))")
                    
                    for href in raw_hrefs:
                        if href is None:
                            continue
                        
                        href = href.strip()
                        
                        if href.startswith('javascript:') or href.startswith('mailto:') or href.startswith('tel:') or href.startswith('#'):
                            continue
                        
                        if href.startswith('http://') or href.startswith('https://'):
                            full_link = href
                        elif href.startswith('//'):
                            full_link = parsed_current_url.scheme + ':' + href
                        elif href.startswith('/'):
                            full_link = f"{parsed_current_url.scheme}://{parsed_current_url.netloc}{href}"
                        else:
                            if '.' in href.split('/')[0] and not href.startswith('.'):
                                continue
                            
                            current_path = parsed_current_url.path
                            if current_path.endswith('/'):
                                full_link = f"{parsed_current_url.scheme}://{parsed_current_url.netloc}{current_path}{href}"
                            else:
                                current_dir = '/'.join(current_path.split('/')[:-1])
                                full_link = f"{parsed_current_url.scheme}://{parsed_current_url.netloc}{current_dir}/{href}"
                        
                        parsed_link = urlparse(full_link)
                        
                        if parsed_link.scheme not in ["http", "https"]:
                            continue

                        if parsed_link.netloc == target_netloc or parsed_link.netloc.endswith('.' + target_netloc):
                            clean_link = f"{parsed_link.scheme}://{parsed_link.netloc}{parsed_link.path}".rstrip('/')
                            if clean_link not in visited_urls:
                                urls_to_visit.add(clean_link)
                    
                    forms = page.query_selector_all("form")
                    if forms:
                        self.log_callback("INFO", f"Encontrados {len(forms)} formulários em {current_url}")
                    for form in forms:
                        try:
                            action = form.get_attribute('action') or current_url
                            inputs = form.query_selector_all('input, textarea, select')
                            input_names = sorted([i.get_attribute('name') for i in inputs if i.get_attribute('name')])
                            form_signature = (urlparse(action).path, tuple(input_names))
                            
                            if form_signature in self.submitted_form_signatures:
                                continue
                            
                            self.log_callback("INFO", f"Preenchendo formulário único: {form_signature}")
                            
                            text_inputs = form.query_selector_all('input[type="text"], input:not([type])')
                            for inp in text_inputs:
                                inp.fill('test')
                            
                            search_inputs = form.query_selector_all('input[type="search"]')
                            for inp in search_inputs:
                                inp.fill('test search')
                            
                            email_inputs = form.query_selector_all('input[type="email"]')
                            for inp in email_inputs:
                                inp.fill('test@test.com')
                            
                            password_inputs = form.query_selector_all('input[type="password"]')
                            for inp in password_inputs:
                                inp.fill('testpassword')
                            
                            textareas = form.query_selector_all('textarea')
                            for ta in textareas:
                                ta.fill('test text area')
                            
                            submit_button = form.query_selector('button[type="submit"], input[type="submit"]')
                            if submit_button:
                                submit_button.click()
                                page.wait_for_load_state('domcontentloaded', timeout=8000)
                                self.submitted_form_signatures.add(form_signature)
                        except PlaywrightTimeoutError:
                            self.log_callback("AVISO", "Timeout ou nenhuma navegação ocorreu após envio de formulário.")
                        except Exception as e:
                            self.log_callback("ERRO", f"Erro ao processar um formulário: {e}")

                except PlaywrightTimeoutError:
                    self.log_callback("AVISO", f"Timeout ao navegar para: {current_url}")
                except Exception as e:
                    self.log_callback("ERRO", f"Erro ao navegar para {current_url}: {e}")
            
            browser.close()
        
        report = "Descoberta Ativa (Browser Playwright):\n" + "\n".join(report_lines) + f"\n- {len(discovered_urls)} URLs/endpoints únicos encontrados."
        return report, discovered_urls

    def _perform_active_scan_on_request(self, request):
        if request.method not in ["GET", "POST"]:
            return

        url = request.url
        parsed_url = urlparse(url)
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
        
        if parsed_url.query:
            query_params = parse_qs(parsed_url.query)
            for param_name in query_params:
                test_signature = ("GET", base_url, param_name)
                if test_signature in self.tested_params:
                    continue
                self.tested_params.add(test_signature)

                self.log_callback("INFO", f"Testando GET '{param_name}' em {base_url}")
                for payload_type, payloads in [("XSS", self.xss_payloads), ("SQLi", self.sqli_payloads), ("LFI", self.lfi_payloads)]:
                    for payload in payloads:
                        modified_params = query_params.copy()
                        modified_params[param_name] = payload
                        new_query = urlencode(modified_params, doseq=True)
                        test_url = f"{base_url}?{new_query}"
                        try:
                            response = self.session.get(test_url, timeout=7)
                            self._check_vulnerability_indicators(response, payload_type, test_url, param_name, payload)
                        except requests.RequestException:
                            pass

        if request.method == "POST" and request.post_data:
            try:
                content_type = request.headers.get("content-type", "")
                if "application/x-www-form-urlencoded" in content_type:
                    post_params = parse_qs(request.post_data)
                    for param_name in post_params:
                        test_signature = ("POST", url, param_name)
                        if test_signature in self.tested_params:
                            continue
                        self.tested_params.add(test_signature)
                        
                        self.log_callback("INFO", f"Testando POST '{param_name}' em {url}")
                        for payload_type, payloads in [("XSS", self.xss_payloads), ("SQLi", self.sqli_payloads)]:
                            for payload in payloads:
                                modified_params = post_params.copy()
                                modified_params[param_name] = payload
                                new_post_data = urlencode(modified_params, doseq=True)
                                try:
                                    response = self.session.post(url, data=new_post_data, headers=request.headers, timeout=7)
                                    self._check_vulnerability_indicators(response, payload_type, url, param_name, payload)
                                except requests.RequestException:
                                    pass
            except Exception:
                pass

    def _check_vulnerability_indicators(self, response, payload_type, tested_url, param_name, payload):
        if payload_type == "XSS" and 'text/html' not in response.headers.get('Content-Type', ''):
            return

        response_text = response.text
        if payload_type == "XSS" and payload in response_text:
            description = f"Possível XSS (Refletido) detectado em '{param_name}' na URL: {tested_url}. O payload injetado foi encontrado na resposta HTML."
            self._add_finding("Alto", description)
            self.log_callback("ALTO", f"Vulnerabilidade (XSS) encontrada! URL: {tested_url}, Parâmetro: {param_name}")
            return

        for indicator in self.vulnerability_indicators.get(payload_type, []):
            if indicator in response_text:
                severity = "Alto" if payload_type == "SQLi" else "Médio"
                description = f"Possível {payload_type} detectado em '{param_name}' na URL: {tested_url}. Indicador: '{indicator}' na resposta."
                self._add_finding(severity, description)
                self.log_callback(severity.upper(), f"Vulnerabilidade ({payload_type}) encontrada! URL: {tested_url}, Parâmetro: {param_name}")
                return

    def _generate_summary(self):
        if not self.findings:
            return "Nenhum risco de segurança foi identificado pelas varreduras."
        report = "SUMÁRIO DE RISCO POR SEVERIDADE:\n\n"
        severities = {"Crítico": [], "Alto": [], "Médio": [], "Baixo": [], "Informativo": []}
        for finding in self.findings:
            severities.setdefault(finding["severity"], []).append(finding["description"])
        
        for severity, items in severities.items():
            if items:
                report += f"--- {severity.upper()} ---\n"
                for item in sorted(list(set(items))):
                    report += f"- {item}\n"
                report += "\n"
        return report